\documentclass{beamer}
\usetheme{metropolis}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{listings}

\usetikzlibrary{positioning,shapes.multipart,calc,arrows,shapes.geometric}

% Definición de colores personalizados
\definecolor{primary}{RGB}{46, 204, 113}
\definecolor{secondary}{RGB}{52, 152, 219}
\definecolor{accent}{RGB}{231, 76, 60}
\definecolor{background}{RGB}{236, 240, 241}
\definecolor{gradient1}{RGB}{255, 107, 107}
\definecolor{gradient2}{RGB}{255, 159, 67}

% Configuración del tema
\setbeamercolor{normal text}{fg=black,bg=background}
\setbeamercolor{structure}{fg=primary}
\setbeamercolor{alerted text}{fg=accent}

\definecolor{lightgray}{rgb}{0.95,0.95,0.95}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}

\lstset{
  backgroundcolor=\color{lightgray},
  basicstyle=\tiny\ttfamily,
  keywordstyle=\color{darkblue}\bfseries,
  commentstyle=\color{darkgreen},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  frame=single,
  tabsize=2,
  language=Python,
  breaklines=true,
  breakatwhitespace=true
}

\title{\Huge\textbf{Simulación de Montecarlo}}
\author{Investigación Operativa}
\date{}

\begin{document}

\begin{frame}
    \titlepage
    \begin{tikzpicture}[remember picture,overlay]
        \node[anchor=south west,inner sep=30pt] at (current page.south west) {
            \includegraphics[height=1cm]{../misc/UdeSA.png}
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}{¿Qué es la simulación de Montecarlo?}
    \begin{center}
        \Large{\textbf{Técnica que usa números aleatorios para resolver problemas}}
    \end{center}
    
    \vspace{1cm}
    
    \textbf{En lugar de resolver analíticamente:}
    \begin{itemize}
        \item Generamos miles de escenarios aleatorios
        \item Ejecutamos nuestro modelo para cada escenario
        \item Analizamos los resultados estadísticamente
    \end{itemize}
    
    \vspace{0.5cm}
    
    \textbf{¿Por qué funciona?} La ley de los grandes números nos dice que el promedio se acerca al valor esperado real.
\end{frame}

\begin{frame}{Proceso de simulación}
    \textbf{Pasos:}
    \begin{enumerate}
        \item Identificar variables aleatorias y parámetros del modelo
        \item Generar valores aleatorios para cada variable (muchas repeticiones)
        \item Ejecutar el modelo para cada escenario simulado
        \item Analizar los resultados (promedios, percentiles, intervalos)
    \end{enumerate}
\end{frame}

\begin{frame}{Distribuciones que usamos}
    \begin{itemize}
        \item \textbf{Uniforme $U(0,1)$}: valores equiprobables entre 0 y 1
        \item \textbf{Normal $N(\mu,\sigma^2)$}: demanda, tiempos; muy común por aproximación
        \item \textbf{Exponencial $Exp(\lambda)$}: tiempos entre llegadas aleatorias independientes
        \item \textbf{Poisson $Pois(\lambda)$}: conteo de eventos en un período fijo
        \item \textbf{Binomial $Bin(n,p)$}: sí/no con ensayos independientes
        \item \textbf{Binomial Negativa $NB(r,p)$}: número de fallas antes de $r$ éxitos.
    \end{itemize}
\end{frame}

\begin{frame}{Análisis de sensibilidad}
    \textbf{¿Qué es?} Una vez que encontramos la solución óptima de nuestro problema, es importante entender qué tan sensible es esta solución a cambios en los parámetros del modelo. El análisis de sensibilidad consiste en variar sistemáticamente uno o más parámetros del modelo y observar cómo cambia la solución óptima.
    
    \vspace{0.3cm}
    
    \textbf{Esto nos permite:}
    \begin{itemize}
        \item Identificar qué parámetros tienen mayor impacto en la solución
        \item Evaluar la robustez de nuestra decisión
        \item Preparar planes de contingencia para diferentes escenarios
    \end{itemize}
\end{frame}

\begin{frame}{¿Cómo sabemos que está bien?}
    \textbf{Problema:} Hay que verificar que los resultados se estabilicen. Si simulamos muy pocas veces, el resultado puede ser muy variable. Si simulamos muchas veces, el resultado se estabiliza.
    
    \vspace{0.3cm}
    
    \textbf{Solución:} La idea es hacer una ``media móvil'': calculamos el promedio de los primeros 1000 resultados, luego de los primeros 2000, 3000, etc. Si el promedio se estabiliza (no cambia mucho), entonces sabemos que tenemos suficientes simulaciones.
\end{frame}

\begin{frame}[fragile]{Código: Verificación de convergencia}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
def verificar_convergencia(resultados, ventana=1000):
    medias_moviles = []
    for i in range(ventana, len(resultados)):
        media_movil = np.mean(resultados[i-ventana:i])
        medias_moviles.append(media_movil)
    
    plt.plot(range(ventana, len(resultados)), medias_moviles)
    plt.xlabel('Numero de iteraciones')
    plt.ylabel('Media movil')
    plt.title('Convergencia de la Simulacion')
    plt.grid(True, alpha=0.3)
    plt.show()
    
    return medias_moviles
    \end{lstlisting}
\end{frame}

\begin{frame}{Problema 1: Gestión de inventario con demanda incierta}
    \textbf{Enunciado}
    
    Tenemos que decidir cuántas unidades pedir cada mes. La demanda es incierta: en promedio se venden 100 unidades pero puede variar (desviación estándar de 20). Los costos son:
    \begin{itemize}
        \item Comprar: \$50 por unidad
        \item Guardar inventario: \$5 por unidad por mes
        \item Quedarse sin stock: \$100 por unidad no servida
    \end{itemize}
    
    Si pedimos poco, nos quedamos sin stock y perdemos ventas. Si pedimos mucho, nos sobra inventario y pagamos costos de almacenamiento. Queremos encontrar la cantidad que minimiza el costo esperado.
\end{frame}

\begin{frame}{Problema 1: Planteo del problema}
    \textbf{Planteo del problema}
    \begin{itemize}
        \item \textbf{Variable de decisión:} $Q$ = cantidad a pedir
        \item \textbf{Variable aleatoria:} $D \sim N(100, 20^2)$, truncada en $0$ para evitar demandas negativas
        \item \textbf{Parámetros:} $c_c=50$ (compra), $c_h=5$ (holding mensual), $c_s=100$ (stockout)
    \end{itemize}
    
    \vspace{0.3cm}
    \textbf{Función objetivo}
    Para una realización de demanda $D$ y una decisión $Q$:
    \[ C(Q, D) = c_c\,Q + c_h\,\max(Q - D, 0) + c_s\,\max(D - Q, 0) \]
    
    \textbf{Objetivo:} Encontrar $Q^*$ que minimiza $E[C(Q, D)]$ mediante simulación.
\end{frame}

\begin{frame}[fragile]{Código: Problema 1 - Simulación base (1/2)}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np
import matplotlib.pyplot as plt

def simulacion_inventario(n_simulaciones=10000):
    # Parametros del problema
    media_demanda = 100
    desvio_demanda = 20
    costo_compra = 50
    costo_almacenamiento = 5
    costo_stockout = 100
    
    # Rango de cantidades a evaluar
    cantidades = range(60, 141, 5)
    costos_promedio = []
    
    for Q in cantidades:
        costos_totales = []
        for _ in range(n_simulaciones):
            # Generar demanda aleatoria
            demanda = max(0, np.random.normal(media_demanda, desvio_demanda))
            
            # Calcular costos
            costo_total = Q * costo_compra
            
            if demanda <= Q:
                # Hay inventario sobrante
                inventario_sobrante = Q - demanda
                costo_total += inventario_sobrante * costo_almacenamiento
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 1 - Simulación base (2/2)}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
            else:
                # Hay stockout
                stockout = demanda - Q
                costo_total += stockout * costo_stockout
            
            costos_totales.append(costo_total)
        costos_promedio.append(np.mean(costos_totales))
    
    return cantidades, costos_promedio

# Ejecutar simulacion
cantidades, costos = simulacion_inventario()

# Encontrar cantidad optima
indice_optimo = np.argmin(costos)
cantidad_optima = list(cantidades)[indice_optimo]
costo_optimo = costos[indice_optimo]

print(f"Cantidad optima: {cantidad_optima} unidades")
print(f"Costo promedio optimo: ${costo_optimo:.2f}")
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 1 - Sensibilidad vs. demanda media (1/2)}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

sim = 10000
desvio_demanda = 20
costo_compra = 50
costo_almacenamiento = 5
costo_stockout = 100

# Rango de demandas medias a evaluar
demandas_medias = np.arange(80, 121, 5)
Q_vals = np.arange(60, 141, 5)
Q_opts = []
C_mins = []

for media_demanda in demandas_medias:
    costos_promedio = []
    
    for Q in Q_vals:
        costos_totales = []
        
        for _ in range(sim):
            # Generar demanda aleatoria
            demanda = max(0, np.random.normal(media_demanda, desvio_demanda))
            
            # Calcular costos
            costo_total = Q * costo_compra
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 1 - Sensibilidad vs. demanda media (2/2)}
    \begin{lstlisting}[numbers=left, numbersep=5pt, firstnumber=21]
            if demanda <= Q:
                inventario_sobrante = Q - demanda
                costo_total += inventario_sobrante * costo_almacenamiento
            else:
                stockout = demanda - Q
                costo_total += stockout * costo_stockout
            
            costos_totales.append(costo_total)
        
        costos_promedio.append(np.mean(costos_totales))
    
    # Encontrar Q optimo para esta demanda media
    idx_optimo = np.argmin(costos_promedio)
    Q_opt = Q_vals[idx_optimo]
    C_min = costos_promedio[idx_optimo]
    
    Q_opts.append(Q_opt)
    C_mins.append(C_min)
    \end{lstlisting}
\end{frame}

\begin{frame}{Problema 2: Optimización de reparto}
    \textbf{Enunciado}
    
    Una empresa de logística busca optimizar la cantidad de repartidores para su servicio de entrega diario. La empresa estima una demanda promedio de 80 pedidos por día. Cada repartidor puede completar 12 entregas diarias, con un costo de contratación de \$120 por día. Adicionalmente, cada pedido que no se logre satisfacer representa un costo de penalización de \$25.
\end{frame}

\begin{frame}{Problema 2: Planteo del problema}
    \textbf{Planteo del problema}
    \begin{itemize}
        \item \textbf{Variable de decisión:} $M$ = número de repartidores a contratar
        \item \textbf{Variable aleatoria:} $D \sim \text{Poisson}(\lambda=80)$ = demanda diaria
        \item \textbf{Parámetros:} $c=12$ (capacidad por repartidor), $c_m=120$ (costo por repartidor), $c_p=25$ (costo de penalización)
    \end{itemize}
    
    \vspace{0.3cm}
    \textbf{Función objetivo}
    Para un día dado, con $M$ repartidores y una demanda $D$, el costo total es:
    \[ C(M,D) = \underbrace{c_m \cdot M}_{\text{Costo Fijo}} + \underbrace{c_p \cdot \max(D - c \cdot M, 0)}_{\text{Costo de Desabastecimiento}} \]
    
    \textbf{Objetivo:} Encontrar $M^*$ que minimice $E[C(M,D)]$ mediante simulación.
\end{frame}

\begin{frame}[fragile]{Código: Problema 2 - Simulación base}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

# parametros del problema
lam = 80
cap_por_repartidor = 12
costo_repartidor = 120
costo_penal = 25
sim = 10000
np.random.seed(42)

M_vals = np.arange(0, 16) # rango de M
costos_prom = []

for M in M_vals:
    # 1) simular demanda
    demanda = np.random.poisson(lam=lam, size=sim)
    # 2) calcular demanda insatisfecha
    capacidad_total = cap_por_repartidor * M
    pedidos_no_servidos = np.maximum(demanda - capacidad_total, 0)
    # 3) costo total
    costo_operativo = costo_repartidor * M
    costo_penalizacion = costo_penal * pedidos_no_servidos
    costo_total = costo_operativo + costo_penalizacion
    costos_prom.append(costo_total.mean())

# elegir M optimo
idx_optimo = np.argmin(costos_prom)
M_opt, C_min = M_vals[idx_optimo], costos_prom[idx_optimo]
print(M_opt, C_min)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 2 - Sensibilidad vs. $\lambda$}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

sim = 10000
cap_por_repartidor = 12
costo_repartidor = 120
costo_penal = 25

lambdas = np.arange(60, 121, 5)
M_vals = np.arange(0, 20)
M_opts = []
C_mins = []

for lam in lambdas:
    costos_prom = []
    for M in M_vals:
        demanda = np.random.poisson(lam=lam, size=sim)
        capacidad_total = cap_por_repartidor * M
        pedidos_no_servidos = np.maximum(demanda - capacidad_total, 0)
        costo_operativo = costo_repartidor * M
        costo_penalizacion_total = costo_penal * pedidos_no_servidos
        costo_total_promedio = (costo_operativo + costo_penalizacion_total).mean()
        costos_prom.append(costo_total_promedio)
    idx_optimo = np.argmin(costos_prom)
    M_opt, C_min = M_vals[idx_optimo], costos_prom[idx_optimo]
    M_opts.append(M_opt)
    C_mins.append(C_min)
    \end{lstlisting}
\end{frame}

\begin{frame}{Problema 3: Optimización de mantenimiento}
    \textbf{Enunciado}
    
    Una fábrica busca optimizar el programa de mantenimiento para una de sus máquinas críticas. Esta máquina sufre una falla catastrófica después de acumular exactamente 5 fallos menores, cuya probabilidad es del 20\%. Para evitar las paradas costosas asociadas a esta falla, se realizan inspecciones preventivas a intervalos fijos de $T$ días. Los costos asociados son:
    \begin{itemize}
        \item Costo Falla Catastrófica ($c_f$): \$10,000 (si falla entre inspecciones)
        \item Costo Inspección ($c_i$): \$400 (por cada visita)
        \item Costo Mantenimiento Preventivo ($c_p$): \$2,000 (adicional si la inspección coincide con el día de la falla)
    \end{itemize}
\end{frame}

\begin{frame}{Problema 3: Planteo del problema}
    \textbf{Planteo del problema}
    \begin{itemize}
        \item \textbf{Variable de decisión:} $T$ = intervalo entre inspecciones (días)
        \item \textbf{Variable aleatoria:} $D$ = duración del ciclo hasta la falla catastrófica
        \item \textbf{Modelo:} $D = D_{fracasos} + r$ donde $D_{fracasos} \sim \text{NegBin}(r=5, p=0.20)$
        \item \textbf{Parámetros:} $c_f=10000$, $c_i=400$, $c_p=2000$
    \end{itemize}
    
    \vspace{0.3cm}
    \textbf{Función objetivo}
    Para un ciclo de duración $D$ y un intervalo $T$:
    \[ C(T, D) = \underbrace{C_{\text{mantenimiento}}(T, D)}_{\text{Preventivo o Catastrófico}} + \underbrace{C_{\text{inspección}}(T, D)}_{\text{Visitas}} \]
    
    \textbf{Objetivo:} Minimizar el Costo Diario Esperado: $E[C_{\text{diario}}(T)] = \frac{E[C(T, D)]}{E[D]}$
\end{frame}

\begin{frame}[fragile]{Código: Problema 3 - Simulación base (1/2)}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

r, p = 5, 0.20
costo_falla_catastrofica = 10000
costo_preventivo = 2000
costo_inspeccion = 400
sim = 20000
np.random.seed(42)

T_vals = np.arange(1, 15)
costos_por_dia = []

for T in T_vals:
    # 1) simular D
    D_fracasos = np.random.negative_binomial(r, p, size=sim)
    D = D_fracasos + r
    # 2) costos de mantenimiento
    mantenimiento_catastrofico = (D % T != 0) * costo_falla_catastrofica
    mantenimiento_preventivo = (D % T == 0) * costo_preventivo
    costo_mantenimiento = mantenimiento_catastrofico + mantenimiento_preventivo
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 3 - Simulación base (2/2)}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
    # 3) costos de inspeccion
    num_inspecciones = np.ceil(D / T)
    costo_inspeccion_ciclo = num_inspecciones * costo_inspeccion
    # 4) costo diario esperado
    costo_total_ciclo = costo_mantenimiento + costo_inspeccion_ciclo
    costo_diario_promedio = costo_total_ciclo.mean() / D.mean()
    costos_por_dia.append(costo_diario_promedio)

idx_optimo = np.argmin(costos_por_dia)
T_opt, C_min = T_vals[idx_optimo], costos_por_dia[idx_optimo]
print(T_opt, C_min)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 3 - Sensibilidad vs. $c_f$ (setup)}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

sim = 10000
r, p = 5, 0.20
costo_preventivo = 2000
costo_inspeccion = 400

cf_vals = np.arange(5000, 20001, 2500)
T_vals = np.arange(1, 15)
T_opts = []
C_mins = []

# media teorica de D
D_mean_fracasos = r * (1 - p) / p
D_mean = D_mean_fracasos + r
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 3 - Sensibilidad vs. $c_f$ (bucle principal)}
    \begin{lstlisting}[numbers=left, numbersep=5pt, firstnumber=15]
for costo_falla_catastrofica in cf_vals:
    costos_diarios_prom = []
    # simular D una sola vez (CRN)
    D_fracasos_sim = np.random.negative_binomial(r, p, size=sim)
    D_sim = D_fracasos_sim + r
    for T in T_vals:
        mantenimiento_catastrofico = (D_sim % T != 0) * costo_falla_catastrofica
        mantenimiento_preventivo = (D_sim % T == 0) * costo_preventivo
        costo_mantenimiento = mantenimiento_catastrofico + mantenimiento_preventivo
        num_inspecciones = np.ceil(D_sim / T)
        costo_inspeccion_ciclo = num_inspecciones * costo_inspeccion
        costo_total_ciclo = costo_mantenimiento + costo_inspeccion_ciclo
        costo_diario_promedio = costo_total_ciclo.mean() / D_mean
        costos_diarios_prom.append(costo_diario_promedio)
    idx_optimo = np.argmin(costos_diarios_prom)
    T_opt, C_min = T_vals[idx_optimo], costos_diarios_prom[idx_optimo]
    T_opts.append(T_opt)
    C_mins.append(C_min)
    \end{lstlisting}
\end{frame}

\begin{frame}{Problema 4: Riesgo en proyecto}
    \textbf{Enunciado}
    
    Una constructora está planificando un proyecto que se desarrolla en tres etapas secuenciales: Diseño, Construcción y Pruebas. Tras consultar con especialistas de cada área, se estima que la duración de cada etapa es incierta pero se dieron estimativos del tiempo mínimo y máximo de cada una. Debido a restricciones de la empresa, el proyecto completo tiene un plazo límite estricto de 25 días. Cada día de retraso más allá de este límite genera un costo de penalización de \$500.
    
    \begin{center}
    \begin{tabular}{|l|c|c|c|}
    \hline
    \textbf{Tarea} & \textbf{Distribución} & \textbf{Mínimo ($a_i$)} & \textbf{Máximo ($b_i$)} \\
    \hline
    A (Diseño) & $\text{Unif}(a_A, b_A)$ & 5 días & 10 días \\
    B (Construcción) & $\text{Unif}(a_B, b_B)$ & 8 días & 15 días \\
    C (Pruebas) & $\text{Unif}(a_C, b_C)$ & 4 días & 7 días \\
    \hline
    \end{tabular}
    \end{center}
\end{frame}

\begin{frame}{Problema 4: Planteo del problema}
    \textbf{Planteo del problema}
    \begin{itemize}
        \item \textbf{Variable aleatoria:} $D_{total} = D_A + D_B + D_C$ donde cada $D_i \sim \text{Unif}(a_i, b_i)$
        \item \textbf{Parámetros:} $L=25$ (límite), $c_p=500$ (penalización por día de retraso)
        \item \textbf{Objetivos:} 
        \begin{itemize}
            \item Estimar $P(D_{total} > 25)$ = probabilidad de retraso
            \item Estimar $E[c_p \cdot \max(0, D_{total} - L)]$ = costo esperado de penalización
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Código: Problema 4 - Simulación base}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

fecha_limite = 25
costo_penalizacion = 500
sim = 100000
np.random.seed(42)

tareas = {'A': (5, 10), 'B': (8, 15), 'C': (4, 7)}

duracion_A = np.random.uniform(tareas['A'][0], tareas['A'][1], size=sim)
duracion_B = np.random.uniform(tareas['B'][0], tareas['B'][1], size=sim)
duracion_C = np.random.uniform(tareas['C'][0], tareas['C'][1], size=sim)
D_total = duracion_A + duracion_B + duracion_C

retraso = np.maximum(D_total - fecha_limite, 0)
E_costo = (retraso * costo_penalizacion).mean()
P_retraso = (D_total > fecha_limite).mean()
print(P_retraso, E_costo)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Código: Problema 4 - Sensibilidad vs. $b_B$}
    \begin{lstlisting}[numbers=left, numbersep=5pt]
import numpy as np

sim = 100000
fecha_limite = 25
costo_penalizacion = 500

tareas_fijas = {'A': (5, 10), 'C': (4, 7)}
a_B = 8

b_B_vals = np.arange(12, 21, 1)
P_retraso_vals = []
E_costo_vals = []

for b_B in b_B_vals:
    duracion_A = np.random.uniform(tareas_fijas['A'][0], tareas_fijas['A'][1], size=sim)
    duracion_B = np.random.uniform(a_B, b_B, size=sim)
    duracion_C = np.random.uniform(tareas_fijas['C'][0], tareas_fijas['C'][1], size=sim)
    D_total = duracion_A + duracion_B + duracion_C
    retraso = np.maximum(D_total - fecha_limite, 0)
    E_costo = (retraso * costo_penalizacion).mean()
    P_retraso = (D_total > fecha_limite).mean()
    P_retraso_vals.append(P_retraso)
    E_costo_vals.append(E_costo)
    \end{lstlisting}
\end{frame}

\begin{frame}{Código básico para distribuciones}
    \begin{itemize}
        \item Uniforme: valores entre $[a,b]$ (ej.: \texttt{np.random.uniform(a,b,n)})
        \item Normal: media $\mu$, desvío $\sigma$ (ej.: \texttt{np.random.normal(mu,sigma,n)})
        \item Exponencial: tasa $\lambda$ (ej.: \texttt{np.random.exponential(1/lambda,n)})
        \item Poisson: tasa $\lambda$ (ej.: \texttt{np.random.poisson(lam,n)})
        \item Binomial: $n$ ensayos, prob. $p$ (ej.: \texttt{np.random.binomial(n,p,nmuestras)})
    \end{itemize}
\end{frame}

\begin{frame}{Terminamos}
    \begin{center}
        \Large{\textbf{¿Dudas?\\¿Consultas?}}
    \end{center}
    \begin{tikzpicture}[remember picture,overlay]
        \node[anchor=south,inner sep=30pt] at (current page.south) {
            \includegraphics[height=1cm]{../misc/UdeSA.png}
        };
    \end{tikzpicture}
\end{frame}

\end{document}
